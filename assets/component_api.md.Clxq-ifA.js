import{_ as a,c as i,o as n,ag as p}from"./chunks/framework.DgsVuIzJ.js";const o=JSON.parse('{"title":"接口管理","description":"","frontmatter":{},"headers":[],"relativePath":"component/api.md","filePath":"component/api.md"}'),t={name:"component/api.md"};function l(e,s,h,k,r,d){return n(),i("div",null,[...s[0]||(s[0]=[p(`<h1 id="接口管理" tabindex="-1">接口管理 <a class="header-anchor" href="#接口管理" aria-label="Permalink to &quot;接口管理&quot;">​</a></h1><p>在项目开发过程中，通常情况下，前端负责开发页面，后端负责开发接口，前端会依赖后端接口提供数据展示页面内容，并实现页面交互，如果没有接口，前端写的页面就是死页面，没有任何交互，但是实际上，前后端都是并行开发，并不会等到后端接口写完，我再开发页面，这样的效率就很低，但是如何解决在没有后端提供接口的前提下，前端也能既把页面写好，又把交互做好，这里我们就会使用 mockjs 来模拟后端接口请求数据，来实现页面渲染和页面交互。</p><div class="danger custom-block"><p class="custom-block-title">DANGER</p><p>我们在开发时，需要注意的是，接口的管理，要按照功能模块去划分，如果不清楚怎么划分，记得一定要去问一下同事，不要因为划分不清楚，导致整个接口管理很混乱，尤其是在多人协作开发的情况下，最终就会导致接口乱七八糟，自己写自己的，只要不报错就可以了。</p></div><h2 id="接口分类" tabindex="-1">接口分类 <a class="header-anchor" href="#接口分类" aria-label="Permalink to &quot;接口分类&quot;">​</a></h2><p>mings-base-frame 前端基础框架，将接口管理分为两类，一类是正式接口的管理，一类是 mock 接口的管理。在基础框架中，管理接口的目录是在 src/apis 下，这个目录作为接口管理的主目录，下面又分为 api 目录（正式接口管理的目录），mock（模拟接口管理的目录）。</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>apis</span></span>
<span class="line"><span>├─ api # 管理正式接口的目录</span></span>
<span class="line"><span>│  ├─ user.ts # 管理用户登录、登出、用户信息、用户菜单、用户权限功能的接口文件</span></span>
<span class="line"><span>│  │</span></span>
<span class="line"><span>│  ├─ module1.ts #  管理module1功能模块的接口文件</span></span>
<span class="line"><span>│  │</span></span>
<span class="line"><span>│  └─ module2.ts #  管理module2功能模块的接口文件</span></span>
<span class="line"><span>└─ mock # 管理mock接口的目录</span></span>
<span class="line"><span>   ├─ user.ts # 管理用户登录、登出、用户信息、用户菜单、用户权限功能的接口文件</span></span>
<span class="line"><span>   │</span></span>
<span class="line"><span>   ├─ module1.ts #  管理module1功能模块的接口文件</span></span>
<span class="line"><span>   │</span></span>
<span class="line"><span>   └─ module2.ts #  管理module2功能模块的接口文件</span></span></code></pre></div><h2 id="接口数据与-ts-类型" tabindex="-1">接口数据与 ts 类型 <a class="header-anchor" href="#接口数据与-ts-类型" aria-label="Permalink to &quot;接口数据与 ts 类型&quot;">​</a></h2><p>按照规范，接口返回的数据都要在一开始写好数据类型，这样我们才能更好的保证项目的稳定性和可维护性，每个数据的类型我们都需要清楚，而不是通过 any 来代替，这样就失去了我们使用 typescript 的意义。而我们写的数据类型怎么和接口请求的数据关联上呢？其实我们在封装 axios 的时候已经做了处理，内部接收一个泛型，当我们调用具体的接口，返回对应的数据，我们就传入对应的 ts 类型。</p><p>我们基础框架中，整个 ts 类型我们都放在 src/types 目录下，这里目录主要用于编写 ts 类型声明文件，可以根据功能模块去划分，每个模块都有自己的类型声明文件，在类型声明文件中，我们可以声明一个命名空间，来区分不同模块下可能会重名的数据类型。目前已经有的是 result.d.ts，这个类型声明文件是接口响应的数据结构类型，这个需要在一开始开发的时候，就和后端约定好，后续所有的接口都会返回这个数据类型。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@author</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> : andy</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@description</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> : 接口响应数据类型</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">declare</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> namespace</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Result</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ResponseResult</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /** 返回状态码 */</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    code</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /** 接口描述信息 */</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    msg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /** 接口数据 */</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Result;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> as</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> namespace</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Result</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>这个 ts 类型我们项目中不会用到，因为他已经被我们封装在 axios 功能内部，这就是为什么我们在使用 axios 写接口请求方法的时候，可以传入一个类型的原因。其实内部接收的就是一个泛型，接口请求时传入什么类型，最终接口响应后就返回什么类型。这就保证我们开发中，请求对应的接口一定能返回对应接口 ts 类型的数据。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 我们在 types 目录下创建了一个user.d.ts类型声明文件</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> User } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;@/types/user&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getUserList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 这里写了User[]类型，返回的就是用户列表类型数据</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> axios</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[]&gt;({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    method: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;get&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    url: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/list&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>当我们调用这个接口 api 获取数据时，我们就能正确的知道返回的数据类型是什么。</p>`,13)])])}const E=a(t,[["render",l]]);export{o as __pageData,E as default};
