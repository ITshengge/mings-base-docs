# 接口管理

在项目开发过程中，通常情况下，前端负责开发页面，后端负责开发接口，前端会依赖后端接口提供数据展示页面内容，并实现页面交互，如果没有接口，前端写的页面就是死页面，没有任何交互，但是实际上，前后端都是并行开发，并不会等到后端接口写完，我再开发页面，这样的效率就很低，但是如何解决在没有后端提供接口的前提下，前端也能既把页面写好，又把交互做好，这里我们就会使用 mockjs 来模拟后端接口请求数据，来实现页面渲染和页面交互。

::: danger
我们在开发时，需要注意的是，接口的管理，要按照功能模块去划分，如果不清楚怎么划分，记得一定要去问一下同事，不要因为划分不清楚，导致整个接口管理很混乱，尤其是在多人协作开发的情况下，最终就会导致接口乱七八糟，自己写自己的，只要不报错就可以了。
:::

## 接口分类

mings-base-frame 前端基础框架，将接口管理分为两类，一类是正式接口的管理，一类是 mock 接口的管理。在基础框架中，管理接口的目录是在 src/apis 下，这个目录作为接口管理的主目录，下面又分为 api 目录（正式接口管理的目录），mock（模拟接口管理的目录）。

```text
apis
├─ api # 管理正式接口的目录
│  ├─ user.ts # 管理用户登录、登出、用户信息、用户菜单、用户权限功能的接口文件
│  │
│  ├─ module1.ts #  管理module1功能模块的接口文件
│  │
│  └─ module2.ts #  管理module2功能模块的接口文件
└─ mock # 管理mock接口的目录
   ├─ user.ts # 管理用户登录、登出、用户信息、用户菜单、用户权限功能的接口文件
   │
   ├─ module1.ts #  管理module1功能模块的接口文件
   │
   └─ module2.ts #  管理module2功能模块的接口文件
```

## 接口数据与 ts 类型

按照规范，接口返回的数据都要在一开始写好数据类型，这样我们才能更好的保证项目的稳定性和可维护性，每个数据的类型我们都需要清楚，而不是通过 any 来代替，这样就失去了我们使用 typescript 的意义。而我们写的数据类型怎么和接口请求的数据关联上呢？其实我们在封装 axios 的时候已经做了处理，内部接收一个泛型，当我们调用具体的接口，返回对应的数据，我们就传入对应的 ts 类型。

我们基础框架中，整个 ts 类型我们都放在 src/types 目录下，这里目录主要用于编写 ts 类型声明文件，可以根据功能模块去划分，每个模块都有自己的类型声明文件，在类型声明文件中，我们可以声明一个命名空间，来区分不同模块下可能会重名的数据类型。目前已经有的是 result.d.ts，这个类型声明文件是接口响应的数据结构类型，这个需要在一开始开发的时候，就和后端约定好，后续所有的接口都会返回这个数据类型。

```ts
/**
 * @author : andy
 * @description : 接口响应数据类型
 */
declare namespace Result {
  interface ResponseResult<T> {
    /** 返回状态码 */
    code: number;
    /** 接口描述信息 */
    msg: string;
    /** 接口数据 */
    data: T;
  }
}
export = Result;
export as namespace Result;
```

这个 ts 类型我们项目中不会用到，因为他已经被我们封装在 axios 功能内部，这就是为什么我们在使用 axios 写接口请求方法的时候，可以传入一个类型的原因。其实内部接收的就是一个泛型，接口请求时传入什么类型，最终接口响应后就返回什么类型。这就保证我们开发中，请求对应的接口一定能返回对应接口 ts 类型的数据。

```ts
// 我们在 types 目录下创建了一个user.d.ts类型声明文件
import { type User } from "@/types/user";
export function getUserList() {
  // 这里写了User[]类型，返回的就是用户列表类型数据
  return axios<User[]>({
    method: "get",
    url: "/list",
  });
}
```

当我们调用这个接口 api 获取数据时，我们就能正确的知道返回的数据类型是什么。
